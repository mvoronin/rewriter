Ilya Bogdanov @vitvakatu 15:19
Просьба использовать play.rust-lang.org для показа кода
https://play.rust-lang.org/?gist=c9ae6a563a3dfad39ae98e95575767eb&version=stable&backtrace=0

Michael Voronin @mvoronin 15:19
хорошо, спасибо за ссылку

Alexander Irbis @alexander-irbis 15:21
@mvoronin в общем, я бы вот так переписал: https://github.com/alexander-irbis/rewriter/blob/master/src/main.rs
Сразу всё скопом долго рассказывать, но можно по частям разобрать, что за магия здесь делается

Alexey Terekhov @a1xt 15:22
а зачем тут Option'ы, если всеравно вызывается паника, когда файл не найден?

Alexander Irbis @alexander-irbis 15:23
В первую очередь, нужно, конечно, заметить, что panic! - это не тот способ, которым нужно завершать программу штатно
@a1xt имя файла может быть задано, а может быть нет, соответственно ввод/вывод - либо из файла, либо с stdin/stdout

Michael Voronin @mvoronin 15:24
да уж, выглядит как магия

Alexander Irbis @alexander-irbis 15:25
@mvoronin её главное понять, после этого - без этой магии - в языках, где нет такой магии - достаточно грустно :grinning:
Я думаю для начала будет интересно перечитать справку на вот этих двух страницах
https://doc.rust-lang.org/std/option/enum.Option.html
https://doc.rust-lang.org/std/result/enum.Result.html
По сути это два фундаментальных для Rust типа, вокруг которых строится львиная доля работы
У обоих типов есть много одинаковых или похожих методов
В первую очередь интересны .map, .map_err и семейство .unwrap*

Michael Voronin @mvoronin 15:29
про Options, Result я читал немного
а вот Box::new, map(|filename| { и .unwrap_or_else(|| Box::new( вижу не первый раз, но вообще не понимаю что происходит
что за две палочки ||?
типа замыкание, ок

Alexander Irbis @alexander-irbis 15:33
Box - это специальный тип владеющей ссылки.
Если & - у нас просто куда-то ссылается и блокирует доступ к данным, то Box - это ссылка на кучу.
С его помощью происходит динамическое управление памятью - память выделяется и освобождается, когда создаётся и уничтожается значение типа Box.
У таких типов как String, Vec, хранящих данные в куче под капотом так или иначе прячется Box.
Дальнейшая магия здесь связана с Trait-object
Trait-object или типаж-объект, кому как больше нравится, позволяет обобщать типы по типажу, отбрасывая информацию по конкретному типу.

Alexander Irbis @alexander-irbis 15:40
Этот механизм в Rust в настоящее время работает при помощи ссылок.
Когда тип является ссылкой указывающей на типаж - в работу включается динамическая диспетчеризация, информация о конкретном типе отбрасывается и у нас остаётся возможность работать только с методами объявленными в типаже.
Это позволяет в одной переменной объединить типы, которые по другому не были бы совместимы (например, потому что у них разный размер), но у этого - своя цена. В данном случае мне пришлось выделять память в куче. Впрочем, это не всегда плохо, просто нужно разобраться чем мы жертвуем.

Michael Voronin @mvoronin 15:42
спасибо за пояснения
тяжело сходу понять, буду читать доки

Alexander Irbis @alexander-irbis 15:44
.map(|val1| val2) - компактный способ преобразовывать значения и при необходимости их типы.
То же самое касается .map_err.
Замыкания в Rust отличаются тем, что для них не обязательно указывать типы как для обычных функций - компилятор часто эти типы может вывести сам из контекста. Ну а когда не может, ему можно давать подсказки, уточняя тип в нужной части.
@mvoronin да, в начале приходится осваивать немаленький пласт информации.
Но как только он усвоится и уляжется - всё становится достаточно просто.
Ну и мы в этом чате собрались, чтоб помогать освоиться :grinning:

Ilya Bogdanov @vitvakatu 15:51
Кстати сказать, есть вопрос. Мне требуется хранить и вызывать функции определенного типа (скажем fn(Vec<String>) -> MyResult. При этом желательно и использовать статически написанные функции, и динамически создаваемые замыкания. Полагаю, единственный способ - boxed Fn?
Не люблю динамическую диспетчеризацию

Alexander Irbis @alexander-irbis 15:53
    let input_buffer = owrp_ifilename // Option<String>
        .map(|filename| File::open(&filename).... ) // открываем файл и возвращаем его -> Option<File>
        .map(|file| Box::new(BufReader::new(file)) as Box<BufRead>) // создаём BufReader и заворачиваем в trait-object -> Option<Box<BufRead>>
        .unwrap_or_else(|| Box::new(BufReader::new(io::stdin())) as Box<BufRead>); // Извлекаем Box<BufRead>,
        // а если значение None, создаём альтернативный Box<BufRead>
        // Благодаря тому, что оригинальный тип стёрт, мы здесь совмещаем два разных типа за ссылкой
@vitvakatu либо на каждое замыкание создаётся новый тип, либо используется динамическая диспетчеризация.
Кстати, не всегда нужно в Box прятать, иногда можно и простой ссылкой обойтись.
Но это уже зависит от того, насколько ты любишь лайфтаймы :grinning:

Alexander Irbis @alexander-irbis 16:06
@mvoronin ещё одно требующее пояснения место:
            File::open(&filename)
                .map_err(|why| panic!("Couldn't open input file \"{}\": {}", filename, why.description()))
                .unwrap()
На самом деле .unwrap() сделает что-то очень похожее на panic!(), только там будет немного другой текст.
Я оставил эту панику только чтобы проиллюстрировать как можно преобразовать
match result { Err(why) => ... }.
С таким же успехом можно написать всё значительно проще, как я в начале предложил с .expect:
            File::open(&filename)
                .expect(format!(r#"Couldn't open input file "{}""#, filename))
И .unwrap() и .expect() так или иначе либо вернут значение из Ok(....), либо вызовут панику с выводом Err(....).

Ilya Bogdanov @vitvakatu 16:10
@alexander-irbis на недавнем митапе Simon Heath сказал "если вам потребовалось хранить в структуре ссылки с лайфтаймами - подумайте еще раз". Разделяю его мнение :smiley:

Alexander Irbis @alexander-irbis 16:10
@mvoronin Когда пишется что-то простое для себя или по быстрому делается прототип - это в принципе то, что надо.
Для продакшена же, когда нужно что-то более надёжное (что месяцами будет крутиться на сервере) и дружелюбное к пользователю (который будет далёк от исходников, а в релизе вообще не будет информации о строках), лучше предусмотреть способ вывода сообщений об ошибках, классические коды возврата для скриптов и т.п. мелочи.
